{"version":3,"file":"request-parser.js","sourceRoot":"","sources":["../../test/request-parser.ts"],"names":[],"mappings":"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","sourcesContent":["const tap = require('tap');\n\nimport * as request from \"../src/request/ApiRequest\";\nimport {ApiRequestPathParser, ApiRequestParser} from \"../src/request/ApiRequestParser\";\nimport {OneToManyRelation} from \"../src/relations/OneToManyRelation\";\nimport {OneToOneRelation} from \"../src/relations/OneToOneRelation\";\nimport {Api} from \"../src/Api\";\n\nconst edge1: any = function() {\n    this.name = \"entry\";\n    this.pluralName = \"entries\";\n    this.relations = [];\n};\n\nconst edge2: any = function() {\n    this.name = \"relatedEntry\";\n    this.pluralName = \"relatedEntries\";\n    this.relations = [];\n};\n\nconst edge3: any = function() {\n    this.name = \"relatedCollectionEntry\";\n    this.pluralName = \"relatedCollection\";\n    this.relations = [];\n};\n\nconst edge: any = new edge1;\nconst relatedEdge: any = new edge2;\nconst relatedCollectionEdge: any = new edge3;\nconst relation: any = new OneToOneRelation(edge, relatedEdge);\nconst collectionRelation: any = new OneToManyRelation(edge, relatedCollectionEdge);\n\nconst parser = new ApiRequestPathParser(\n    new Api('1.0')\n        .edge(edge)\n        .edge(relatedEdge)\n        .edge(relatedCollectionEdge)\n        .relation(relation)\n        .relation(collectionRelation)\n);\n\ntap.test('path should be empty when the input array is empty', (t: any) => {\n    var path = parser.parse([]);\n    t.equal(path.segments.length, 0);\n    t.end()\n});\n\ntap.test('parser should not allow missing edges', (t: any) => {\n    t.throws(() => { parser.parse([ 'test' ]) }, 'Missing Edge: test', 'should not allow missing start edge');\n    t.throws(() => { parser.parse([ 'entries', '42', 'test' ]) }, 'Missing Edge: test', 'should not allow missing related field/method 1');\n    t.throws(() => { parser.parse([ 'entries', '42', 'relatedField', 'test' ]) }, 'Missing Edge: test', 'should not allow missing related field/method 2');\n    t.throws(() => { parser.parse([ 'entries', '42', 'relatedField', 'relatedCollection' ]) }, 'Missing Relation: relatedEntry -> relatedCollection', 'should not allow missing relation');\n    t.end()\n});\n\ntap.test('parser should parse single edge segment request', (t: any) => {\n    var path = parser.parse([ 'entries' ]);\n    t.equal(path.segments.length, 1, 'should have one segment');\n    t.ok(path.segments[0] instanceof request.EdgePathSegment, 'should have an edge path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal(path.segments[0].relation, null, 'should have no relation');\n    t.end()\n});\n\ntap.test('parser should parse single entry segment request', (t: any) => {\n    var path = parser.parse([ 'entries', '42' ]);\n    t.equal(path.segments.length, 1, 'should have one segment');\n    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal((path.segments[0] as request.EntryPathSegment).id, '42', 'id should be the provided');\n    t.equal(path.segments[0].relation, null, 'should have no relation');\n    t.end()\n});\n\ntap.test('parser should parse single related entry segment request', (t: any) => {\n    var path = parser.parse([ 'entries', '42', 'relatedEntry' ]);\n    t.equal(path.segments.length, 2, 'should have two segments');\n\n    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal((path.segments[0] as request.EntryPathSegment).id, '42', 'id should be the provided');\n    t.equal(path.segments[0].relation, null, 'should have no relation');\n\n    t.ok(path.segments[1] instanceof request.RelatedFieldPathSegment, 'should have a related field path segment');\n    t.equal(path.segments[1].edge, edge, 'should be the registered edge');\n    t.equal(path.segments[1].relation, relation, 'should be the registered relation');\n\n    t.end()\n});\n\ntap.test('parser should parse single related collection segment request', (t: any) => {\n    var path = parser.parse([ 'entries', '42', 'relatedCollection' ]);\n    t.equal(path.segments.length, 2, 'should have two segments');\n\n    t.ok(path.segments[0] instanceof request.EntryPathSegment, 'should have an entry path segment');\n    t.equal(path.segments[0].edge, edge, 'should be the registered edge');\n    t.equal((path.segments[0] as request.EntryPathSegment).id, '42', 'id should be the provided');\n    t.equal(path.segments[0].relation, null, 'should have no relation');\n\n    t.ok(path.segments[1] instanceof request.EdgePathSegment, 'should have an edge path segment');\n    t.equal(path.segments[1].edge, relatedCollectionEdge, 'should be the registered edge');\n    t.equal(path.segments[1].relation, collectionRelation, 'should be the registered relation');\n\n    t.end()\n});\n\ntap.test('unsupported relation should cause error', (t: any) => {\n    var unsupportedRelation: any = function() {\n        this.name = \"unsupported\";\n        this.from = edge;\n        this.to = relatedEdge;\n    };\n\n    var badParser = new ApiRequestPathParser(\n        new Api('1.0')\n            .edge(edge)\n            .edge(relatedEdge)\n            .relation(new unsupportedRelation)\n    );\n\n    t.throws(() => { badParser.parse([ 'entries', '42', 'unsupported' ]) }, 'Unsupported Relation');\n    t.end()\n});\n\ntap.test('request parser should work too', (t: any) => {\n    var requestParser = new ApiRequestParser(new Api('1.0'));\n    var request = requestParser.parse([]);\n    t.equal(request.path.segments.length, 0);\n    t.end()\n});"]}