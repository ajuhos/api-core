{"version":3,"file":"ApiEdgeSchema.js","sourceRoot":"","sources":["../../../src/edge/ApiEdgeSchema.ts"],"names":[],"mappings":"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","sourcesContent":["const parse = require('obj-parse'),\n    deepKeys = require('deep-keys');\n\nexport class ApiEdgeSchemaTransformation {\n    applyToInput: (schema: any, model: any) => void;\n    applyToOutput: (mode: any, schema: any) => void;\n    affectedSchemaField: string;\n    affectedModelFields: string[];\n    parsedField: any;\n\n    constructor(input: (schema: any, model: any) => void,\n                output: (model: any, schema: any) => void,\n                modelFields: string[],\n                schemaField: string = \"\") {\n        this.applyToInput = input;\n        this.applyToOutput = output;\n        this.affectedSchemaField = schemaField;\n        this.affectedModelFields = modelFields;\n        this.parsedField = parse(schemaField);\n    }\n\n    setSchemaField(field: string) {\n        this.affectedSchemaField = field;\n        this.parsedField = parse(field);\n    }\n}\n\nexport class ApiEdgeSchema {\n    fields: string[];\n    transformations: ApiEdgeSchemaTransformation[];\n\n    private fieldMatrix: any = {};\n    transformFields = (fields: string[]): string[] => {\n        let output: string[] = [];\n        fields.forEach((field: string) => {\n            const transformedFields = this.fieldMatrix[field];\n            if(transformedFields) {\n                transformedFields.forEach((f: string) => output.push(f))\n            }\n            else output.push(field)\n        });\n        return output\n    };\n\n    private static createInputTransformer(schemaField: any, transform: string): (schem: any, model: any) => void {\n        if(transform === \"=\") {\n            return (schema: any, model: any) => schemaField.assign(model, schemaField(schema));\n        }\n        else if(transform[0] === \"=\") {\n            const fieldName = transform.substring(1),\n                modelField = parse(fieldName);\n\n            return (model: any, schema: any) => modelField.assign(model, schemaField(schema));\n        }\n        else throw \"Not Supported Transform\";\n    }\n\n    private static createOutputTransformer(schemaField: any, transform: string): (model: any, schema: any) => void {\n        if(transform === \"=\") {\n            return (model: any, schema: any) => schemaField.assign(schema, schemaField(model));\n        }\n        else if(transform[0] === \"=\") {\n            const fieldName = transform.substring(1),\n                modelField = parse(fieldName);\n\n            return (model: any, schema: any) => schemaField.assign(schema, modelField(model));\n        }\n        else {\n            throw \"Not Supported Transform\";\n        }\n    }\n\n    private createTransformation(schemaField: string, schema: any): ApiEdgeSchemaTransformation|undefined {\n        const parsedSchemaField = parse(schemaField),\n            transform: string|ApiEdgeSchemaTransformation = parsedSchemaField(schema);\n\n        if(transform instanceof ApiEdgeSchemaTransformation) {\n            transform.setSchemaField(schemaField);\n\n            let transformedFields = this.fieldMatrix[transform.affectedSchemaField];\n            if(transformedFields) {\n                transform.affectedModelFields.forEach((field: string) => transformedFields.push(field))\n            }\n            else {\n                this.fieldMatrix[transform.affectedSchemaField]\n                    = transform.affectedModelFields.map((field: string) => field)\n            }\n\n            this.fixFields(schemaField);\n\n            return transform;\n        }\n        else if(typeof transform === \"string\") {\n            return new ApiEdgeSchemaTransformation(\n                ApiEdgeSchema.createInputTransformer(parsedSchemaField, transform),\n                ApiEdgeSchema.createOutputTransformer(parsedSchemaField, transform),\n                [ schemaField ],\n                schemaField\n            );\n        }\n    }\n\n    private fixFields(fieldName: string) {\n        this.fields = this.fields.filter((field: string) => field.indexOf(fieldName+\".\") == -1)\n    }\n\n    constructor(schema: any) {\n        this.fields = deepKeys(schema, true);\n        this.transformations = [];\n        for(let i = 0; i < this.fields.length; ++i) {\n            const transform = this.createTransformation(this.fields[i], schema);\n            if(transform)\n                this.transformations.push(transform)\n        }\n    }\n}"]}